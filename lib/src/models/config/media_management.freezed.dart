// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'media_management.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

SonarrMediaManagementConfig _$SonarrMediaManagementConfigFromJson(
    Map<String, dynamic> json) {
  return _SonarrMediaManagementConfig.fromJson(json);
}

/// @nodoc
mixin _$SonarrMediaManagementConfig {
  int get id => throw _privateConstructorUsedError;
  bool get autoUnmonitorPreviouslyDownloadedEpisodes =>
      throw _privateConstructorUsedError;
  String? get recycleBin => throw _privateConstructorUsedError;
  int get recycleBinCleanupDays => throw _privateConstructorUsedError;
  SonarrProperDownloadType get downloadPropersAndRepacks =>
      throw _privateConstructorUsedError;
  bool get createEmptySeriesFolders => throw _privateConstructorUsedError;
  bool get deleteEmptyFolders => throw _privateConstructorUsedError;
  SonarrFileDateType get fileDate => throw _privateConstructorUsedError;
  SonarrRescanAfterRefreshType get rescanAfterRefresh =>
      throw _privateConstructorUsedError;
  bool get setPermissionsLinux => throw _privateConstructorUsedError;
  String? get chmodFolder => throw _privateConstructorUsedError;
  String? get chownGroup => throw _privateConstructorUsedError;
  SonarrEpisodeTitleRequiredType get episodeTitleRequired =>
      throw _privateConstructorUsedError;
  bool get skipFreeSpaceCheckWhenImporting =>
      throw _privateConstructorUsedError;
  int get minimumFreeSpaceWhenImporting => throw _privateConstructorUsedError;
  bool get copyUsingHardlinks => throw _privateConstructorUsedError;
  bool get importExtraFiles => throw _privateConstructorUsedError;
  String? get extraFileExtensions => throw _privateConstructorUsedError;
  bool get enableMediaInfo => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SonarrMediaManagementConfigCopyWith<SonarrMediaManagementConfig>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SonarrMediaManagementConfigCopyWith<$Res> {
  factory $SonarrMediaManagementConfigCopyWith(
          SonarrMediaManagementConfig value,
          $Res Function(SonarrMediaManagementConfig) then) =
      _$SonarrMediaManagementConfigCopyWithImpl<$Res,
          SonarrMediaManagementConfig>;
  @useResult
  $Res call(
      {int id,
      bool autoUnmonitorPreviouslyDownloadedEpisodes,
      String? recycleBin,
      int recycleBinCleanupDays,
      SonarrProperDownloadType downloadPropersAndRepacks,
      bool createEmptySeriesFolders,
      bool deleteEmptyFolders,
      SonarrFileDateType fileDate,
      SonarrRescanAfterRefreshType rescanAfterRefresh,
      bool setPermissionsLinux,
      String? chmodFolder,
      String? chownGroup,
      SonarrEpisodeTitleRequiredType episodeTitleRequired,
      bool skipFreeSpaceCheckWhenImporting,
      int minimumFreeSpaceWhenImporting,
      bool copyUsingHardlinks,
      bool importExtraFiles,
      String? extraFileExtensions,
      bool enableMediaInfo});
}

/// @nodoc
class _$SonarrMediaManagementConfigCopyWithImpl<$Res,
        $Val extends SonarrMediaManagementConfig>
    implements $SonarrMediaManagementConfigCopyWith<$Res> {
  _$SonarrMediaManagementConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? autoUnmonitorPreviouslyDownloadedEpisodes = null,
    Object? recycleBin = freezed,
    Object? recycleBinCleanupDays = null,
    Object? downloadPropersAndRepacks = null,
    Object? createEmptySeriesFolders = null,
    Object? deleteEmptyFolders = null,
    Object? fileDate = null,
    Object? rescanAfterRefresh = null,
    Object? setPermissionsLinux = null,
    Object? chmodFolder = freezed,
    Object? chownGroup = freezed,
    Object? episodeTitleRequired = null,
    Object? skipFreeSpaceCheckWhenImporting = null,
    Object? minimumFreeSpaceWhenImporting = null,
    Object? copyUsingHardlinks = null,
    Object? importExtraFiles = null,
    Object? extraFileExtensions = freezed,
    Object? enableMediaInfo = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      autoUnmonitorPreviouslyDownloadedEpisodes: null ==
              autoUnmonitorPreviouslyDownloadedEpisodes
          ? _value.autoUnmonitorPreviouslyDownloadedEpisodes
          : autoUnmonitorPreviouslyDownloadedEpisodes // ignore: cast_nullable_to_non_nullable
              as bool,
      recycleBin: freezed == recycleBin
          ? _value.recycleBin
          : recycleBin // ignore: cast_nullable_to_non_nullable
              as String?,
      recycleBinCleanupDays: null == recycleBinCleanupDays
          ? _value.recycleBinCleanupDays
          : recycleBinCleanupDays // ignore: cast_nullable_to_non_nullable
              as int,
      downloadPropersAndRepacks: null == downloadPropersAndRepacks
          ? _value.downloadPropersAndRepacks
          : downloadPropersAndRepacks // ignore: cast_nullable_to_non_nullable
              as SonarrProperDownloadType,
      createEmptySeriesFolders: null == createEmptySeriesFolders
          ? _value.createEmptySeriesFolders
          : createEmptySeriesFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      deleteEmptyFolders: null == deleteEmptyFolders
          ? _value.deleteEmptyFolders
          : deleteEmptyFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      fileDate: null == fileDate
          ? _value.fileDate
          : fileDate // ignore: cast_nullable_to_non_nullable
              as SonarrFileDateType,
      rescanAfterRefresh: null == rescanAfterRefresh
          ? _value.rescanAfterRefresh
          : rescanAfterRefresh // ignore: cast_nullable_to_non_nullable
              as SonarrRescanAfterRefreshType,
      setPermissionsLinux: null == setPermissionsLinux
          ? _value.setPermissionsLinux
          : setPermissionsLinux // ignore: cast_nullable_to_non_nullable
              as bool,
      chmodFolder: freezed == chmodFolder
          ? _value.chmodFolder
          : chmodFolder // ignore: cast_nullable_to_non_nullable
              as String?,
      chownGroup: freezed == chownGroup
          ? _value.chownGroup
          : chownGroup // ignore: cast_nullable_to_non_nullable
              as String?,
      episodeTitleRequired: null == episodeTitleRequired
          ? _value.episodeTitleRequired
          : episodeTitleRequired // ignore: cast_nullable_to_non_nullable
              as SonarrEpisodeTitleRequiredType,
      skipFreeSpaceCheckWhenImporting: null == skipFreeSpaceCheckWhenImporting
          ? _value.skipFreeSpaceCheckWhenImporting
          : skipFreeSpaceCheckWhenImporting // ignore: cast_nullable_to_non_nullable
              as bool,
      minimumFreeSpaceWhenImporting: null == minimumFreeSpaceWhenImporting
          ? _value.minimumFreeSpaceWhenImporting
          : minimumFreeSpaceWhenImporting // ignore: cast_nullable_to_non_nullable
              as int,
      copyUsingHardlinks: null == copyUsingHardlinks
          ? _value.copyUsingHardlinks
          : copyUsingHardlinks // ignore: cast_nullable_to_non_nullable
              as bool,
      importExtraFiles: null == importExtraFiles
          ? _value.importExtraFiles
          : importExtraFiles // ignore: cast_nullable_to_non_nullable
              as bool,
      extraFileExtensions: freezed == extraFileExtensions
          ? _value.extraFileExtensions
          : extraFileExtensions // ignore: cast_nullable_to_non_nullable
              as String?,
      enableMediaInfo: null == enableMediaInfo
          ? _value.enableMediaInfo
          : enableMediaInfo // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SonarrMediaManagementConfigCopyWith<$Res>
    implements $SonarrMediaManagementConfigCopyWith<$Res> {
  factory _$$_SonarrMediaManagementConfigCopyWith(
          _$_SonarrMediaManagementConfig value,
          $Res Function(_$_SonarrMediaManagementConfig) then) =
      __$$_SonarrMediaManagementConfigCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      bool autoUnmonitorPreviouslyDownloadedEpisodes,
      String? recycleBin,
      int recycleBinCleanupDays,
      SonarrProperDownloadType downloadPropersAndRepacks,
      bool createEmptySeriesFolders,
      bool deleteEmptyFolders,
      SonarrFileDateType fileDate,
      SonarrRescanAfterRefreshType rescanAfterRefresh,
      bool setPermissionsLinux,
      String? chmodFolder,
      String? chownGroup,
      SonarrEpisodeTitleRequiredType episodeTitleRequired,
      bool skipFreeSpaceCheckWhenImporting,
      int minimumFreeSpaceWhenImporting,
      bool copyUsingHardlinks,
      bool importExtraFiles,
      String? extraFileExtensions,
      bool enableMediaInfo});
}

/// @nodoc
class __$$_SonarrMediaManagementConfigCopyWithImpl<$Res>
    extends _$SonarrMediaManagementConfigCopyWithImpl<$Res,
        _$_SonarrMediaManagementConfig>
    implements _$$_SonarrMediaManagementConfigCopyWith<$Res> {
  __$$_SonarrMediaManagementConfigCopyWithImpl(
      _$_SonarrMediaManagementConfig _value,
      $Res Function(_$_SonarrMediaManagementConfig) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? autoUnmonitorPreviouslyDownloadedEpisodes = null,
    Object? recycleBin = freezed,
    Object? recycleBinCleanupDays = null,
    Object? downloadPropersAndRepacks = null,
    Object? createEmptySeriesFolders = null,
    Object? deleteEmptyFolders = null,
    Object? fileDate = null,
    Object? rescanAfterRefresh = null,
    Object? setPermissionsLinux = null,
    Object? chmodFolder = freezed,
    Object? chownGroup = freezed,
    Object? episodeTitleRequired = null,
    Object? skipFreeSpaceCheckWhenImporting = null,
    Object? minimumFreeSpaceWhenImporting = null,
    Object? copyUsingHardlinks = null,
    Object? importExtraFiles = null,
    Object? extraFileExtensions = freezed,
    Object? enableMediaInfo = null,
  }) {
    return _then(_$_SonarrMediaManagementConfig(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      autoUnmonitorPreviouslyDownloadedEpisodes: null ==
              autoUnmonitorPreviouslyDownloadedEpisodes
          ? _value.autoUnmonitorPreviouslyDownloadedEpisodes
          : autoUnmonitorPreviouslyDownloadedEpisodes // ignore: cast_nullable_to_non_nullable
              as bool,
      recycleBin: freezed == recycleBin
          ? _value.recycleBin
          : recycleBin // ignore: cast_nullable_to_non_nullable
              as String?,
      recycleBinCleanupDays: null == recycleBinCleanupDays
          ? _value.recycleBinCleanupDays
          : recycleBinCleanupDays // ignore: cast_nullable_to_non_nullable
              as int,
      downloadPropersAndRepacks: null == downloadPropersAndRepacks
          ? _value.downloadPropersAndRepacks
          : downloadPropersAndRepacks // ignore: cast_nullable_to_non_nullable
              as SonarrProperDownloadType,
      createEmptySeriesFolders: null == createEmptySeriesFolders
          ? _value.createEmptySeriesFolders
          : createEmptySeriesFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      deleteEmptyFolders: null == deleteEmptyFolders
          ? _value.deleteEmptyFolders
          : deleteEmptyFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      fileDate: null == fileDate
          ? _value.fileDate
          : fileDate // ignore: cast_nullable_to_non_nullable
              as SonarrFileDateType,
      rescanAfterRefresh: null == rescanAfterRefresh
          ? _value.rescanAfterRefresh
          : rescanAfterRefresh // ignore: cast_nullable_to_non_nullable
              as SonarrRescanAfterRefreshType,
      setPermissionsLinux: null == setPermissionsLinux
          ? _value.setPermissionsLinux
          : setPermissionsLinux // ignore: cast_nullable_to_non_nullable
              as bool,
      chmodFolder: freezed == chmodFolder
          ? _value.chmodFolder
          : chmodFolder // ignore: cast_nullable_to_non_nullable
              as String?,
      chownGroup: freezed == chownGroup
          ? _value.chownGroup
          : chownGroup // ignore: cast_nullable_to_non_nullable
              as String?,
      episodeTitleRequired: null == episodeTitleRequired
          ? _value.episodeTitleRequired
          : episodeTitleRequired // ignore: cast_nullable_to_non_nullable
              as SonarrEpisodeTitleRequiredType,
      skipFreeSpaceCheckWhenImporting: null == skipFreeSpaceCheckWhenImporting
          ? _value.skipFreeSpaceCheckWhenImporting
          : skipFreeSpaceCheckWhenImporting // ignore: cast_nullable_to_non_nullable
              as bool,
      minimumFreeSpaceWhenImporting: null == minimumFreeSpaceWhenImporting
          ? _value.minimumFreeSpaceWhenImporting
          : minimumFreeSpaceWhenImporting // ignore: cast_nullable_to_non_nullable
              as int,
      copyUsingHardlinks: null == copyUsingHardlinks
          ? _value.copyUsingHardlinks
          : copyUsingHardlinks // ignore: cast_nullable_to_non_nullable
              as bool,
      importExtraFiles: null == importExtraFiles
          ? _value.importExtraFiles
          : importExtraFiles // ignore: cast_nullable_to_non_nullable
              as bool,
      extraFileExtensions: freezed == extraFileExtensions
          ? _value.extraFileExtensions
          : extraFileExtensions // ignore: cast_nullable_to_non_nullable
              as String?,
      enableMediaInfo: null == enableMediaInfo
          ? _value.enableMediaInfo
          : enableMediaInfo // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SonarrMediaManagementConfig implements _SonarrMediaManagementConfig {
  const _$_SonarrMediaManagementConfig(
      {required this.id,
      required this.autoUnmonitorPreviouslyDownloadedEpisodes,
      this.recycleBin,
      required this.recycleBinCleanupDays,
      required this.downloadPropersAndRepacks,
      required this.createEmptySeriesFolders,
      required this.deleteEmptyFolders,
      required this.fileDate,
      required this.rescanAfterRefresh,
      required this.setPermissionsLinux,
      this.chmodFolder,
      this.chownGroup,
      required this.episodeTitleRequired,
      required this.skipFreeSpaceCheckWhenImporting,
      required this.minimumFreeSpaceWhenImporting,
      required this.copyUsingHardlinks,
      required this.importExtraFiles,
      this.extraFileExtensions,
      required this.enableMediaInfo});

  factory _$_SonarrMediaManagementConfig.fromJson(Map<String, dynamic> json) =>
      _$$_SonarrMediaManagementConfigFromJson(json);

  @override
  final int id;
  @override
  final bool autoUnmonitorPreviouslyDownloadedEpisodes;
  @override
  final String? recycleBin;
  @override
  final int recycleBinCleanupDays;
  @override
  final SonarrProperDownloadType downloadPropersAndRepacks;
  @override
  final bool createEmptySeriesFolders;
  @override
  final bool deleteEmptyFolders;
  @override
  final SonarrFileDateType fileDate;
  @override
  final SonarrRescanAfterRefreshType rescanAfterRefresh;
  @override
  final bool setPermissionsLinux;
  @override
  final String? chmodFolder;
  @override
  final String? chownGroup;
  @override
  final SonarrEpisodeTitleRequiredType episodeTitleRequired;
  @override
  final bool skipFreeSpaceCheckWhenImporting;
  @override
  final int minimumFreeSpaceWhenImporting;
  @override
  final bool copyUsingHardlinks;
  @override
  final bool importExtraFiles;
  @override
  final String? extraFileExtensions;
  @override
  final bool enableMediaInfo;

  @override
  String toString() {
    return 'SonarrMediaManagementConfig(id: $id, autoUnmonitorPreviouslyDownloadedEpisodes: $autoUnmonitorPreviouslyDownloadedEpisodes, recycleBin: $recycleBin, recycleBinCleanupDays: $recycleBinCleanupDays, downloadPropersAndRepacks: $downloadPropersAndRepacks, createEmptySeriesFolders: $createEmptySeriesFolders, deleteEmptyFolders: $deleteEmptyFolders, fileDate: $fileDate, rescanAfterRefresh: $rescanAfterRefresh, setPermissionsLinux: $setPermissionsLinux, chmodFolder: $chmodFolder, chownGroup: $chownGroup, episodeTitleRequired: $episodeTitleRequired, skipFreeSpaceCheckWhenImporting: $skipFreeSpaceCheckWhenImporting, minimumFreeSpaceWhenImporting: $minimumFreeSpaceWhenImporting, copyUsingHardlinks: $copyUsingHardlinks, importExtraFiles: $importExtraFiles, extraFileExtensions: $extraFileExtensions, enableMediaInfo: $enableMediaInfo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SonarrMediaManagementConfig &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.autoUnmonitorPreviouslyDownloadedEpisodes,
                    autoUnmonitorPreviouslyDownloadedEpisodes) ||
                other.autoUnmonitorPreviouslyDownloadedEpisodes ==
                    autoUnmonitorPreviouslyDownloadedEpisodes) &&
            (identical(other.recycleBin, recycleBin) ||
                other.recycleBin == recycleBin) &&
            (identical(other.recycleBinCleanupDays, recycleBinCleanupDays) ||
                other.recycleBinCleanupDays == recycleBinCleanupDays) &&
            (identical(other.downloadPropersAndRepacks, downloadPropersAndRepacks) ||
                other.downloadPropersAndRepacks == downloadPropersAndRepacks) &&
            (identical(other.createEmptySeriesFolders, createEmptySeriesFolders) ||
                other.createEmptySeriesFolders == createEmptySeriesFolders) &&
            (identical(other.deleteEmptyFolders, deleteEmptyFolders) ||
                other.deleteEmptyFolders == deleteEmptyFolders) &&
            (identical(other.fileDate, fileDate) ||
                other.fileDate == fileDate) &&
            (identical(other.rescanAfterRefresh, rescanAfterRefresh) ||
                other.rescanAfterRefresh == rescanAfterRefresh) &&
            (identical(other.setPermissionsLinux, setPermissionsLinux) ||
                other.setPermissionsLinux == setPermissionsLinux) &&
            (identical(other.chmodFolder, chmodFolder) ||
                other.chmodFolder == chmodFolder) &&
            (identical(other.chownGroup, chownGroup) ||
                other.chownGroup == chownGroup) &&
            (identical(other.episodeTitleRequired, episodeTitleRequired) ||
                other.episodeTitleRequired == episodeTitleRequired) &&
            (identical(other.skipFreeSpaceCheckWhenImporting, skipFreeSpaceCheckWhenImporting) ||
                other.skipFreeSpaceCheckWhenImporting ==
                    skipFreeSpaceCheckWhenImporting) &&
            (identical(other.minimumFreeSpaceWhenImporting, minimumFreeSpaceWhenImporting) ||
                other.minimumFreeSpaceWhenImporting ==
                    minimumFreeSpaceWhenImporting) &&
            (identical(other.copyUsingHardlinks, copyUsingHardlinks) ||
                other.copyUsingHardlinks == copyUsingHardlinks) &&
            (identical(other.importExtraFiles, importExtraFiles) ||
                other.importExtraFiles == importExtraFiles) &&
            (identical(other.extraFileExtensions, extraFileExtensions) ||
                other.extraFileExtensions == extraFileExtensions) &&
            (identical(other.enableMediaInfo, enableMediaInfo) || other.enableMediaInfo == enableMediaInfo));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        autoUnmonitorPreviouslyDownloadedEpisodes,
        recycleBin,
        recycleBinCleanupDays,
        downloadPropersAndRepacks,
        createEmptySeriesFolders,
        deleteEmptyFolders,
        fileDate,
        rescanAfterRefresh,
        setPermissionsLinux,
        chmodFolder,
        chownGroup,
        episodeTitleRequired,
        skipFreeSpaceCheckWhenImporting,
        minimumFreeSpaceWhenImporting,
        copyUsingHardlinks,
        importExtraFiles,
        extraFileExtensions,
        enableMediaInfo
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SonarrMediaManagementConfigCopyWith<_$_SonarrMediaManagementConfig>
      get copyWith => __$$_SonarrMediaManagementConfigCopyWithImpl<
          _$_SonarrMediaManagementConfig>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SonarrMediaManagementConfigToJson(
      this,
    );
  }
}

abstract class _SonarrMediaManagementConfig
    implements SonarrMediaManagementConfig {
  const factory _SonarrMediaManagementConfig(
      {required final int id,
      required final bool autoUnmonitorPreviouslyDownloadedEpisodes,
      final String? recycleBin,
      required final int recycleBinCleanupDays,
      required final SonarrProperDownloadType downloadPropersAndRepacks,
      required final bool createEmptySeriesFolders,
      required final bool deleteEmptyFolders,
      required final SonarrFileDateType fileDate,
      required final SonarrRescanAfterRefreshType rescanAfterRefresh,
      required final bool setPermissionsLinux,
      final String? chmodFolder,
      final String? chownGroup,
      required final SonarrEpisodeTitleRequiredType episodeTitleRequired,
      required final bool skipFreeSpaceCheckWhenImporting,
      required final int minimumFreeSpaceWhenImporting,
      required final bool copyUsingHardlinks,
      required final bool importExtraFiles,
      final String? extraFileExtensions,
      required final bool enableMediaInfo}) = _$_SonarrMediaManagementConfig;

  factory _SonarrMediaManagementConfig.fromJson(Map<String, dynamic> json) =
      _$_SonarrMediaManagementConfig.fromJson;

  @override
  int get id;
  @override
  bool get autoUnmonitorPreviouslyDownloadedEpisodes;
  @override
  String? get recycleBin;
  @override
  int get recycleBinCleanupDays;
  @override
  SonarrProperDownloadType get downloadPropersAndRepacks;
  @override
  bool get createEmptySeriesFolders;
  @override
  bool get deleteEmptyFolders;
  @override
  SonarrFileDateType get fileDate;
  @override
  SonarrRescanAfterRefreshType get rescanAfterRefresh;
  @override
  bool get setPermissionsLinux;
  @override
  String? get chmodFolder;
  @override
  String? get chownGroup;
  @override
  SonarrEpisodeTitleRequiredType get episodeTitleRequired;
  @override
  bool get skipFreeSpaceCheckWhenImporting;
  @override
  int get minimumFreeSpaceWhenImporting;
  @override
  bool get copyUsingHardlinks;
  @override
  bool get importExtraFiles;
  @override
  String? get extraFileExtensions;
  @override
  bool get enableMediaInfo;
  @override
  @JsonKey(ignore: true)
  _$$_SonarrMediaManagementConfigCopyWith<_$_SonarrMediaManagementConfig>
      get copyWith => throw _privateConstructorUsedError;
}
