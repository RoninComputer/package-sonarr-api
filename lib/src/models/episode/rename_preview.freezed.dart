// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'rename_preview.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

SonarrEpisodeRenamePreview _$SonarrEpisodeRenamePreviewFromJson(
    Map<String, dynamic> json) {
  return _SonarrEpisodeRenamePreview.fromJson(json);
}

/// @nodoc
mixin _$SonarrEpisodeRenamePreview {
  int? get id => throw _privateConstructorUsedError;
  int get seriesId => throw _privateConstructorUsedError;
  int get seasonNumber => throw _privateConstructorUsedError;
  List<int> get episodeNumbers => throw _privateConstructorUsedError;
  int get episodeFileId => throw _privateConstructorUsedError;
  String? get existingPath => throw _privateConstructorUsedError;
  String? get newPath => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SonarrEpisodeRenamePreviewCopyWith<SonarrEpisodeRenamePreview>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SonarrEpisodeRenamePreviewCopyWith<$Res> {
  factory $SonarrEpisodeRenamePreviewCopyWith(SonarrEpisodeRenamePreview value,
          $Res Function(SonarrEpisodeRenamePreview) then) =
      _$SonarrEpisodeRenamePreviewCopyWithImpl<$Res,
          SonarrEpisodeRenamePreview>;
  @useResult
  $Res call(
      {int? id,
      int seriesId,
      int seasonNumber,
      List<int> episodeNumbers,
      int episodeFileId,
      String? existingPath,
      String? newPath});
}

/// @nodoc
class _$SonarrEpisodeRenamePreviewCopyWithImpl<$Res,
        $Val extends SonarrEpisodeRenamePreview>
    implements $SonarrEpisodeRenamePreviewCopyWith<$Res> {
  _$SonarrEpisodeRenamePreviewCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? seriesId = null,
    Object? seasonNumber = null,
    Object? episodeNumbers = null,
    Object? episodeFileId = null,
    Object? existingPath = freezed,
    Object? newPath = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      seriesId: null == seriesId
          ? _value.seriesId
          : seriesId // ignore: cast_nullable_to_non_nullable
              as int,
      seasonNumber: null == seasonNumber
          ? _value.seasonNumber
          : seasonNumber // ignore: cast_nullable_to_non_nullable
              as int,
      episodeNumbers: null == episodeNumbers
          ? _value.episodeNumbers
          : episodeNumbers // ignore: cast_nullable_to_non_nullable
              as List<int>,
      episodeFileId: null == episodeFileId
          ? _value.episodeFileId
          : episodeFileId // ignore: cast_nullable_to_non_nullable
              as int,
      existingPath: freezed == existingPath
          ? _value.existingPath
          : existingPath // ignore: cast_nullable_to_non_nullable
              as String?,
      newPath: freezed == newPath
          ? _value.newPath
          : newPath // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SonarrEpisodeRenamePreviewCopyWith<$Res>
    implements $SonarrEpisodeRenamePreviewCopyWith<$Res> {
  factory _$$_SonarrEpisodeRenamePreviewCopyWith(
          _$_SonarrEpisodeRenamePreview value,
          $Res Function(_$_SonarrEpisodeRenamePreview) then) =
      __$$_SonarrEpisodeRenamePreviewCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? id,
      int seriesId,
      int seasonNumber,
      List<int> episodeNumbers,
      int episodeFileId,
      String? existingPath,
      String? newPath});
}

/// @nodoc
class __$$_SonarrEpisodeRenamePreviewCopyWithImpl<$Res>
    extends _$SonarrEpisodeRenamePreviewCopyWithImpl<$Res,
        _$_SonarrEpisodeRenamePreview>
    implements _$$_SonarrEpisodeRenamePreviewCopyWith<$Res> {
  __$$_SonarrEpisodeRenamePreviewCopyWithImpl(
      _$_SonarrEpisodeRenamePreview _value,
      $Res Function(_$_SonarrEpisodeRenamePreview) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? seriesId = null,
    Object? seasonNumber = null,
    Object? episodeNumbers = null,
    Object? episodeFileId = null,
    Object? existingPath = freezed,
    Object? newPath = freezed,
  }) {
    return _then(_$_SonarrEpisodeRenamePreview(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      seriesId: null == seriesId
          ? _value.seriesId
          : seriesId // ignore: cast_nullable_to_non_nullable
              as int,
      seasonNumber: null == seasonNumber
          ? _value.seasonNumber
          : seasonNumber // ignore: cast_nullable_to_non_nullable
              as int,
      episodeNumbers: null == episodeNumbers
          ? _value._episodeNumbers
          : episodeNumbers // ignore: cast_nullable_to_non_nullable
              as List<int>,
      episodeFileId: null == episodeFileId
          ? _value.episodeFileId
          : episodeFileId // ignore: cast_nullable_to_non_nullable
              as int,
      existingPath: freezed == existingPath
          ? _value.existingPath
          : existingPath // ignore: cast_nullable_to_non_nullable
              as String?,
      newPath: freezed == newPath
          ? _value.newPath
          : newPath // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SonarrEpisodeRenamePreview implements _SonarrEpisodeRenamePreview {
  const _$_SonarrEpisodeRenamePreview(
      {this.id,
      required this.seriesId,
      required this.seasonNumber,
      required final List<int> episodeNumbers,
      required this.episodeFileId,
      this.existingPath,
      this.newPath})
      : _episodeNumbers = episodeNumbers;

  factory _$_SonarrEpisodeRenamePreview.fromJson(Map<String, dynamic> json) =>
      _$$_SonarrEpisodeRenamePreviewFromJson(json);

  @override
  final int? id;
  @override
  final int seriesId;
  @override
  final int seasonNumber;
  final List<int> _episodeNumbers;
  @override
  List<int> get episodeNumbers {
    if (_episodeNumbers is EqualUnmodifiableListView) return _episodeNumbers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_episodeNumbers);
  }

  @override
  final int episodeFileId;
  @override
  final String? existingPath;
  @override
  final String? newPath;

  @override
  String toString() {
    return 'SonarrEpisodeRenamePreview(id: $id, seriesId: $seriesId, seasonNumber: $seasonNumber, episodeNumbers: $episodeNumbers, episodeFileId: $episodeFileId, existingPath: $existingPath, newPath: $newPath)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SonarrEpisodeRenamePreview &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.seriesId, seriesId) ||
                other.seriesId == seriesId) &&
            (identical(other.seasonNumber, seasonNumber) ||
                other.seasonNumber == seasonNumber) &&
            const DeepCollectionEquality()
                .equals(other._episodeNumbers, _episodeNumbers) &&
            (identical(other.episodeFileId, episodeFileId) ||
                other.episodeFileId == episodeFileId) &&
            (identical(other.existingPath, existingPath) ||
                other.existingPath == existingPath) &&
            (identical(other.newPath, newPath) || other.newPath == newPath));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      seriesId,
      seasonNumber,
      const DeepCollectionEquality().hash(_episodeNumbers),
      episodeFileId,
      existingPath,
      newPath);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SonarrEpisodeRenamePreviewCopyWith<_$_SonarrEpisodeRenamePreview>
      get copyWith => __$$_SonarrEpisodeRenamePreviewCopyWithImpl<
          _$_SonarrEpisodeRenamePreview>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SonarrEpisodeRenamePreviewToJson(
      this,
    );
  }
}

abstract class _SonarrEpisodeRenamePreview
    implements SonarrEpisodeRenamePreview {
  const factory _SonarrEpisodeRenamePreview(
      {final int? id,
      required final int seriesId,
      required final int seasonNumber,
      required final List<int> episodeNumbers,
      required final int episodeFileId,
      final String? existingPath,
      final String? newPath}) = _$_SonarrEpisodeRenamePreview;

  factory _SonarrEpisodeRenamePreview.fromJson(Map<String, dynamic> json) =
      _$_SonarrEpisodeRenamePreview.fromJson;

  @override
  int? get id;
  @override
  int get seriesId;
  @override
  int get seasonNumber;
  @override
  List<int> get episodeNumbers;
  @override
  int get episodeFileId;
  @override
  String? get existingPath;
  @override
  String? get newPath;
  @override
  @JsonKey(ignore: true)
  _$$_SonarrEpisodeRenamePreviewCopyWith<_$_SonarrEpisodeRenamePreview>
      get copyWith => throw _privateConstructorUsedError;
}
